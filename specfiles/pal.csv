CLI input,Pal output,explanation
pal help,usage: pal <command>\n  pal chat - enters pal interactive mode\n  pal chat [prompt] - creates a cli command based on your prompt and asks if you would like to execute the command\n  pal chat --vibe <prompt> - creates a cli command and automatically executes the command.\n  pal exec <script name> [prompt] - execute the script using the prompt to fill out the script parameters.,Enters the help route and returns text
pal chat create a commit message based on my diff,I've created a script in ~/.pal/command/tmp/commit.sh.\n  `pal exec --temp commit`\nWould you like to execute? (y/n),Enters the chat route and process the prompt via an llm. The llm sees this is a multi-step process so it generates a bash script that would get the work done. The bash script gets saved to ~/.pal/command/tmp because this script hasn't explicitly been created by the user yet. Tmp scripts get deleted after 1 week if they are not saved by the user. The command that pal generated is a command to execute the created script. Pal is now waiting for a response from the user of whether that command should be executed since this is not running in vibe mode. If it were in vibe mode it would have executed the command immediately.
y,Executing `pal exec --temp commit`\n  Checking git diff of staged work...\n  Reaching llm for summary of work...\n  Generating commit...\n  Complete!\n  Your script has been executed. If you would like to save the script run `pal save commit`,Since pal got an affirmative response it executes the command and outputs the logs. If the command had interactive elements it would allow the user to respond to the script interactions. If pal execs a temporary script then it gives a helpful message on how you can save the script.
pal save commit,Saved the script to ~/.pal/command/commit.sh\nYou can execute it any time by running `pal exec commit`,Enters the save route which looks for a tmp script with the same filename and saves it to a permanent directory that will not be deleted automatically. Every time a command is saved a manifest with all the commands is updated. This manifest is in ~/.pal/commands/.commandManifest.json. The manifest can be used to determine which commands are available and what they are useful for and what parameters the commands take. Pal then gives a helpful message on how you can execute the script.
pal chat create a commit message based on my diff,I see an existing script that would help with this.\n  `pal exec commit`\nWould you like to execute? (y/n),Enters the chat route. Since a manifest file exists pal will include it in the prompt to the llm. The llm will be prompted to use a pal exec command if a script already exists. The llm will return the pal exec command due to how it is prompted. Pal asks the user to confirm if the user would like to execute the command.
y,Executing `pal exec commit`\n  Checking git diff of staged work...\n  Reaching llm for summary of work...\n  Generating commit...\n Complete!\n Your script has been executed.,Since pal recieved y it will execute the command. The remaining text are the logs from the script.
pal exec ls all .txt files,Executing `pal exec --param 'filetype=txt' Continue? (y/n)`,ls is a prebuilt exec script that was provided with pal. Pal enters the exec route and uses the command manifest to check if the ls script exists. It also uses the manifest to check if any parameters are required or optional in the script. Pal should have discovered that the ls script is in ~/.pal/commands/ls.sh and takes optional parameters. It sends the script and the prompt provided by the user "all .txt files" to the llm to generate a viable command for the prompt. The llm should respond with the command `pal exec --param 'filetype=txt'`. Pal takes that response and sends it to the user asking if they would like to execute it.
y,  notes.txt\n  hello.txt,Since pal recieved y it will execute the command. The remaining text are the logs from the script showing a list of all text files in the current directory.
pal exec commit in all CAPS,The commit script is not configurable. Would you like me to update the script to make it configurable so that it can accommodate your prompt `in all CAPS` (y/n)?,Enters the exec route and checks if the script exists and if it has any parameters using the command manifest. Since the commit script has no parameters Pal asks the user if they would like to update the script.
y,I've updated your script in ~/.pal/command/tmp/commit.sh.\n `pal exec --temp commit --param 'isCaps=True`\nWould you like to execute? (y/n),Since the user entered 'y' the exec route continues and Pal sends a prompt to the llm with the existing script and the parameter it needs to adapt. The llm should return the new script. Pal saves that new script in the tmp directory. Then Pal sees if the user wants to execute the new change.
y,Executing `pal exec --temp commit --param 'isCaps=True`\n  Checking git diff of staged work...\n  Reaching llm for summary of work...\n  Generating commit with all cap\n  Complete!\nYour script has been executed. If you would like to save the script run `pal save commit`,Since the user entered 'y' the exec route continues and the command is executed. When pal exec is called with temp it automatically outputs a suggestion that the user save the script.
pal save commit,You are overriding an existing script. Are you sure you want to proceed? (y/n),Enters the save route which checks the tmp directory for the commit script and also checks if a script with the same name already exists. Since the script already exists Pal needs confirmation that the user would like to override the existing script.
y,Saved the script to ~/.pal/command/commit.sh\nYou can execute it any time by running `pal exec commit`,Since the user entered 'y' the save route continues and the commit script is moved from the temporary script directory to the permanent script directory.
pal chat --vibe find all .img files recursively,  `find . -type f -name "*.img"`\n    ./smile.img\n    ./pal.img,Enters the chat route and process the prompt via an llm. The llm sees it is a simple command so it doesn't generate a script but directly gives a shell command. Pal immediately executes the command since the vibe flag is present.
pal save find --last,Saved the last executed command to ~/.pal/command/find\nYou can execute it any time by running `pal exec find`,Enters the save route. Pal saves the last command that was executed since the last flag is used.
pal exec find all .txt and .img files recursively,The find script is not configurable. Would you like me to update the script to make it configurable so that it can accomodate your prompt 'all .txt files recursively' (y/n)?,Enters the exec route and sees that the find command is not configuratble. Pal asks if the user if they would like to update the script.
y,I've updated your script in ~/.pal/command/tmp/find.sh\n `pal exec --temp find --param 'fileType=[img txt]'`\nWould you like to execute? (y/n),Since the user entered 'y' the exec route continues and Pal sends a prompt to the llm with the existing find script and the parameter is needs to adapt. The llm should return the new script. Pal saves the script in the tmp directory. Then Pal asks if the user would like to execute the script.
y,Executing `pal exec --temp find --param 'fileType=[img txt]'`\n  ./smile.img\n  ./pal.img\n  ./prompts/pal.txt\n  ./prompts/smile.txt\nYour script has been executed. If you would like to save the script run `pal save find`,Since the user entered 'y' the exec route continues and the command is executed. When pal exec is called with the temp flag it automatically outputs a suggestion that the user save the script.
pal list,Default scripts:\n  list - pretty prints files in the current directory\nCustom scripts:\n  commit - creates a commit from the existing staged changes\nfind - finds files of specified type in the directory,The list command lists all saved scripts. The scripts can be the included ones and custom ones and temporary ones.
pal stage note "script that appends a note to running notes",I've created a script in ~/.pal/command/tmp/notes.sh\n,The stage command creates a script to be staged.